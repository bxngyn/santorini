# Observer pattern
We used the observer pattern to observe whether the game has ended. This is in the Observer class. We created an inherited subclass 
EndGameOberserver which is attached to and observes the GameManager as the subject.
A game ends whenever a worker moves onto a building of height 3 or the current player having no available moves left. Whenever the game 
ending condition is met, the GameManager subject notifies the observer that the state is "end". This triggers the observer to then ask the 
user if they would like to restart the game, then restarts if yes, or exits the program if no.

# Template pattern
We used the template pattern to implement the different players' behavior during their turn, as the behavior is dependent on whether the 
player is a human, random computer, or heuristic computer. This is in the TurnTemplate class.
We decided to use the template pattern here because each type of player has the data, just different behavior. For instance, at each turn, 
we always need to know the board, player, and game manager. The behavior during the turn, however, is different for different player types: 
for instance, humans should be prompted for input, random computers should make decisions randomly, and heuristic computers should make 
calculated decisions. Thus we save the constant data as instances in the TurnTemplate class which each subclass HumanTurn, RandomTurn and
HeuristicTurn inherit, and have these subclasses write their own turn behaviors to override the template's abstractly implemented behavior.

# Memento pattern
We used the memento pattern to implement the undo and redo feature in the Memento class. This was the obvious pattern choice for undo/redo 
as it allowed the program to save and restore previous states of the game. 
We created a GameState class which stored all the information needed for each state or round of the game, such as the board, the players, 
the turn count, and the score. We then added this GameState as an instance of the GameManager object. Every time undo or redo is called, 
the GameManager's GameState is updated to reflect the restored game state. 
Additionally, examples of memento we went over in class only covered undo functionality. To implement the redo functionality, we created 
another list "undone" which has the current game state appended to every time "undo" is called, such that when "redo" is called, we can pop 
off the last game state that was undone in the "undone" list. It is essentially the opposite of undo.

# Command pattern
We used the command pattern to allow Player objects to call move and build, which has functionality in the GameManger object. This is in the 
Command class. We created an abstract Command class and 2 subclasses MoveCommand and BuildCommand which inherit from Command.
Players objects can call move or build, which creates an instance of the MoveCommand or BuildCommand class. When the Player calls 
.execute() on these instances, the Command class acts as the middleman and communicates with the GameManager to execute move() or build() 
on the specified worker and direction.